# -*- mode: sh; coding: utf-8 -*-

[ -f /etc/zsh/zshrc ] && source /etc/zsh/zshrc

############################################################
##  外部設定ファイル

source_if_exist(){
    if [ ! -f "$1" ]
    then
        echo cannot load "$1"
        return 1
    fi
    echo load "$1"
    source "$1"
}

## rvm
source_if_exist "/usr/local/rvm/scripts/rvm"
source_if_exist "$HOME/.rvm/scripts/rvm"

## nvm
source_if_exist "$HOME/.nvm/nvm.sh"

############################################################
# java
JAVA=`which java 2>/dev/null`
if [ $? -eq 0 ]
then
    if [ -x /usr/libexec/java_home ]
    then
        JAVA_HOME="`/usr/libexec/java_home`"
    else
        JAVA="`readlink -n -f $JAVA`"
        JAVA_BIN="`dirname $JAVA`"
        JAVA_HOME="`dirname $JAVA_BIN`"
    fi
    export JAVA_HOME
fi

############################################################
# パスの設定
## (N-/): 存在しないディレクトリは登録しない。
##    パス(...): ...という条件にマッチするパスのみ残す。
##            N: NULL_GLOBオプションを設定。
##               globがマッチしなかったり存在しないパスを無視する。
##            -: シンボリックリンク先のパスを評価。
##            /: ディレクトリのみ残す。
path=(
    $HOME/.{setting,dotfile}s/bin(N-/)
    $HOME/{.rvm,.rbenv,local,.local}/bin(N-/)
    $HOME/.nodebrew/current/bin(N-/)
    node_modules/.bin
    $GEM_HOME/bin(N-/)
    $path
    /usr/local/{rvm,rbenv}/bin(N-/)
    /app/{script,mingw/tdm/bin,gs/bin,gs/lib}(N-/)
    /usr{/local,/usr,}/bin(N-/)
)
## 重複したパスを登録しない。
typeset -U path

############################################################
# sudo時のパスの設定
## -x: export SUDO_PATHも一緒に行う。
## -T: SUDO_PATHとsudo_pathを連動する。
typeset -xT SUDO_PATH sudo_path
sudo_path=({,/usr/pkg,/usr/local,/usr}/sbin(N-/)
        $sudo_path $path)
## 重複したパスを登録しない。
typeset -U sudo_path

if [ $TERM = "xterm" ] && infocmp xterm-256color > /dev/null 2>&1
then
    export TERM="xterm-256color"
fi

# 表示言語設定
export LANG=ja_JP.UTF-8

# 補完スクリプトのパス
fpath=(
    {$HOME/.rvm,/usr/local/rvm}/scripts/zsh/Completion(N-/)
    $HOME/.zshrc.d/grunt-zsh-completion(N-/)
    $HOME/.zshrc.d/completion(N-/)
    $HOME/.zshrc.d/zsh-completions/src(N-/)
    $fpath)

## 補完機能の強化
autoload -U compinit
compinit -u

_cake(){
    if [[ -f Cakefile ]]
    then
        compadd $(cake | grep '^cake ' | sed -e "s/cake \([^ ]*\) .*/\1/" | grep -v '^$')
    fi
}
compdef _cake cake

# reffer https://github.com/RiotGames/berkshelf/blob/master/berkshelf-complete.sh
_berks(){
    compadd $(berks help | grep -E '^ +berks' | cut -d' ' -f4)
}
compdef _berks berks

_kitchen(){
    compadd $(kitchen help | grep -E '^ +kitchen' | cut -d' ' -f4)
}
compdef _kitchen kitchen

############################################################
## alias, funcction の設定
if which screen > /dev/null 2>&1
then
    alias s="screen"
    [ $STY ] && alias s="screen -X focus; screen"
fi

if ls --color > /dev/null 2>&1
then
    alias ls="ls -F --color"
elif ls -G > /dev/null 2>&1
then
    alias ls="ls -F -G"
fi

function markdown_preview(){
    if [ $# -ne 1 ]; then
        echo "error: invalid arguments"
        echo "usage: $0 markdown_file"
        return 1;
    fi

    if [ ! -f "$1" ]; then
        echo "error: $1 dose not exists"
        return 1;
    fi

    md "$1" | w3m -T text/html -dump

    # 縦割りしたときにズレる問題解決
    if [ $STY ]
    then
        sleep 0.2
        screen -X redisplay
    fi
}

function j(){
    class=`echo $1 | sed -e "s/\\.java$//"`
    shift
    echo $@
    if [ -f build.xml ]; then
        ant && java -DDebug=on $class $@
    else
        javac $class.java && java -DDebug=on $do_java $@
    fi
}

# HTTPサーバを立ち上げる
function serve(){
    local port=8007

    local dir file
    if [[ $# -eq 0 ]]; then
        # no-op
    elif [[ -d "$1" ]]; then
        local dir="$1"
    elif [[ -f "$1" ]]; then
        local dir="$(dirname "$1")"
        local file="$(basename "$1")"
    fi
    [[ -n "$dir" ]] && pushd "$dir" $>/dev/null

    local url="http://localhost:$port/$file"

    if [[ -n "$dir" ]]
    then color256_echo 0 5 0 "Serve $dir"
    else color256_echo 0 5 0 "Serve the current directory"
    fi
    python -m SimpleHTTPServer $port &

    color256_echo 0 5 0 "Open $url"
    if which sensible-browser &> /dev/null; then
        sensible-browser "$url"
    elif which xdg-open &> /dev/null; then
        xdg-open "$url"
    fi
    fg

    [[ -n "$dir" ]] && popd $>/dev/null
}
alias http-serve=serve

# screen のコピー機能と、X Window System のクリップボードの同期
if which xsel > /dev/null 2>&1
then
    # X Window System 環境でのコピー （xsel をインストールする必要あり）
    copy_cmd="xsel -i -b < /tmp/screen-exchange;\
              xsel -i -p < /tmp/screen-exchange"
elif which pbcopy > /dev/null 2>&1
then
    # Mac OS X 環境でのコピー （要動作テスト）
    copy_cmd="pbcopy < /tmp/screen-exchange"
elif which putclip > /dev/null 2>&1
then
    # Cygwin 環境でのコピー（要動作テスト）
    copy_cmd="putclip < /tmp/screen-exchange"
fi
[ $DISPLAY ] && [ $STY ] && [ $copy_cmd ] &&\
  screen -X bindkey -m ' ' eval "stuff ' '" writebuf "exec sh -c '$copy_cmd'"

## emacs server の設定
if (which emacs && which emacsclient) > /dev/null
then
    if [ -z "$EMACS_SERVER_NAME" ]
    then
        EMACS_SERVER_NAME="${USER}-tty-`basename ${TTY}`"
        # [ $STY ] && EMACS_SERVER_NAME="${USER}-sty-${STY}"
        [ $DISPLAY ] && EMACS_SERVER_NAME="${USER}-wm-${DISPLAY}"
        export EMACS_SERVER_NAME
    fi

    which start_emacsclient > /dev/null 2>&1 && \
      alias e="start_emacsclient --no-wait"
    alias emacsclient="emacsclient --socket-name \"$EMACS_SERVER_NAME\""

    which start_emacsclient > /dev/null 2>&1 && \
      export EDITOR=start_emacsclient
fi

## 色一覧
color_list(){
    for c in {000..015}
    do
        echo -n "\e[38;5;${c}m $c"
        [ $((c%8)) -eq 7 ] && echo
    done

    for c in {016..255}
    do
        echo -n "\e[38;5;${c}m $c"
        [ $(((c-16)%6)) -eq 5 ] && echo
    done
}

# open
if [ -f /usr/bin/xdg-open ]
then
    alias open=/usr/bin/xdg-open
fi
alias o=open

## 256色生成用便利関数
### red: 0-5
### green: 0-5
### blue: 0-5
color256(){
    echo -n $(($1 * 36 + $2 * 6 + $3 + 16))
}

color256_echo(){
    if [ $# -lt 3 ]
    then
        echo "usage: $0 RED GREEN BLUE [string...]"
        echo "  RED, GREEN, BLUE: 0-5"
        echo "sample: $0 0 5 5 foo"
        return 1
    fi

    local r=$1; shift
    local g=$1; shift
    local b=$1; shift

    echo "\e[38;5;`color256 $r $g $b`m$@\e[39m"
}

#####################################################################
# バージョンシステム管理下のディレクトリにいる時の諸々の設定
autoload -Uz vcs_info
zstyle ':vcs_info:*' get-revision true
zstyle ':vcs_info:*' check-for-changes true
zstyle ':vcs_info:*' max-exports 6
zstyle ':vcs_info:*' formats '%s' '%b' '%i' '%c' '%u'
zstyle ':vcs_info:*' actionformats '%s' '%b' '%i' '%c' '%u' '%a'

# インデックスに追加された場合に表示される文字列
# zstyle ':vcs_info:git:*' stagedstr "S"
# 作業コピーに変更があった場合に表示される文字列
# zstyle ':vcs_info:git:*' unstagedstr "U"

# bzr のとき、vcs_info でネットワーク使わせない
zstyle ':vcs_info:bzr:*' use-simple true

update_vcs_info(){
    LANG=en_US.UTF-8 vcs_info

    export VCS_NAME=$vcs_info_msg_0_
    export VCS_BRANCH_NAME=$vcs_info_msg_1_
    export VCS_REVISION=$vcs_info_msg_2_
    export VCS_ACTION=$vcs_info_msg_5_

    VCS_IS_COMMITED=t
    [[ -n "$vcs_info_msg_3_" ]] && VCS_IS_COMMITED=
    export VCS_IS_COMMITED

    VCS_IS_ADDED=t
    [[ -n "$vcs_info_msg_4_" ]] && VCS_IS_ADDED=
    export VCS_IS_ADDED
}
precmd_functions=($precmd_functions update_vcs_info)

#########################################################################
##    プロンプト を生成
colors=(
    # $'\e[0;30m' # black
    $'\e[0;31m' # red
    $'\e[0;32m' # green
    $'\e[0;33m' # brown
    $'\e[0;34m' # blue
    $'\e[0;35m' # purple
    $'\e[0;36m' # cyan
    # $'\e[0;37m' # gray

    # light colors
    # $'\e[1;30m' # black
    $'\e[1;31m' # red
    $'\e[1;32m' # green
    $'\e[1;33m' # brown
    $'\e[1;34m' # blue
    $'\e[1;35m' # purple
    $'\e[1;36m' # cyan
    # $'\e[1;37m' # gray
)

if [ `echotc Co` = "256" ]
then
    colors=()
    local c=0
    for c in {000..255}
    do
        # 無視する色
        if [ $c -eq 000 ] || [ $c -ge 016 -a $c -le 031 ] ||\
           [ $c -ge 052 -a $c -le 068 ] || [ $c -ge 088 -a $c -le 098 ] ||\
           [ $c -ge 230 -a $c -le 255 ]
        then
            continue
        fi
        colors=($colors $'\e[38;5;'$c'm')
    done
fi

export USER_COLOR=$colors[$((`echo "$USER" | sum | cut -f1 -d' '`%${#colors}))+1]
export HOST_COLOR=$colors[$((`echo "$HOST" | sum | cut -f1 -d' '`%${#colors}))+1]
export BAR_COLOR=$'\e[0;37m'
export TIME_COLOR=$'\e[0;37m'
if [ `echotc Co` = "256" ]
then
    export BAR_COLOR=$'\e[38;5;240m'
    export TIME_COLOR=$'\e[38;5;245m'
fi

echo_vcs_info(){
    local color=
    if [[ -z "$1" ]]
    then
        if [[ -n "$VCS_IS_ADDED" && -n "$VCS_IS_COMMITED" ]]
        then color='%F{green}'
        else color='%F{red}'
        fi
    fi
    [[ -n "$VCS_NAME" ]] && echo -n "$color$VCS_NAME:$VCS_BRANCH_NAME"
    [[ -n "$VCS_ACTION" ]] && echo -n "[$VCS_ACTION]"
}

export _RBENV_RUBY_VERSION=
update_rbenv_info(){
    local basepath=$PWD
    local version_file=

    while [[ "/" != "$basepath" ]]
    do
        version_file="$basepath/.ruby-version"
        [[ -f "$version_file" ]] && break
        basepath=$( dirname "$basepath" )
    done

    export _RBENV_RUBY_VERSION="$(
        [[ -f "$version_file" ]] && head -1 "$version_file"
    )"
}
precmd_functions=($precmd_functions update_rbenv_info)

echo_rbenv_info(){
    [[ -n "$_RBENV_RUBY_VERSION" ]] &&  echo -n "rb$_RBENV_RUBY_VERSION"
}

export JOBS=0
update_jobs_num(){
    export JOBS=$( jobs | grep -E '^\[[0-9]*\] ' | wc -l )
}
precmd_functions=($precmd_functions update_jobs_num)

echo_jobs_num(){
    local c= d=
    if [[ -z "$1" ]]
    then c="%F{green}" d="%f"
    fi
    [[ "$JOBS" -ne 0 ]] && echo -n "jobs:$c${JOBS}$d"
}

construct_left(){
    local no_color=
    while getopts n opt
    do
        case $opt in
            n) no_color=true;;
        esac
    done
    shift `expr $OPTIND - 1`
    local current_path=$1

    local u= h= p= d=
    if [[ -z "$no_color" ]]
    then
        u=$USER_COLOR
        h=$HOST_COLOR
        p='%F{yellow}'
        d='%f'
    fi

    local extra_info= info=
    for info in "$( echo_vcs_info $no_color )" "$( echo_rbenv_info $no_color )" \
        "$( echo_jobs_num $no_color )"
    do [[ -n "$info" ]] && extra_info=($extra_info $info)
    done

    # プロンプトのフォーマット
    echo -n "$u${USER}$d@$h${HOST}$d:$p${current_path}"
    if [[ -n "$extra_info" ]]
    then
        for info in $extra_info
        do echo -n "$d :$info"
        done
        echo -n "$d"
    fi
}

update_prompt(){
    local columns=$((COLUMNS - 2))
    local escaped_home="`echo ${HOME}|sed -e 's/\//\\\\\//g'`"
    local current_path="`pwd|sed -e \"s/^${escaped_home}/~/\"`"
    local left="$(construct_left -n $current_path)"

    # build right
    local right=" $(date +'%Y/%m/%d %H:%M:%S') "
    local num_bar=$((${columns}-${#left}-${#right}))
    if [[ $num_bar -lt 0 ]]
    then
        right=" $(date +'%H:%M:%S') "
        num_bar=$((${columns}-${#left}-${#right}))
        if [[ $num_bar -lt 0 ]]
        then
            right=''
            num_bar=$((${columns}-${#left}-${#right}))
        fi
    fi

    # build bar
    local bar= sep=' -'
    while [[ $num_bar -gt $((${#bar}+${#sep})) ]]
    do bar="$sep$bar"
    done
    while [[ $num_bar -gt ${#bar} ]]
    do bar="$bar "
    done

    bar="$BAR_COLOR$bar"
    right="$TIME_COLOR$right"
    left="$(construct_left $current_path)"
    PROMPT=$'\n'"${left}${bar}${right}"$'\n'"%f%(!.#.$) "
}
precmd_functions=($precmd_functions update_prompt)
PROMPT="${USER_COLOR}${USER}%f@${HOST_COLOR}${HOST}%f %F{yellow}%~%f "$'\n'"%(!.#.$) "
ORIGIN_TTY=$(echo $STY | sed --silent -e 's/.*\.pts-\([0-9]*\)\..*/\1/p')

############################################################
##  screen の window タイトルを設定
update_screen_title() {
    [[ -z "$STY" ]] && return

    local shell=$(echo -n ${SHELL} | sed -e 's/^.*\///')
    local dir=$(print -P '%~' | sed 's/ /_/g' | xargs -I '{}' basename "{}")
    echo -n "\033k${shell}#${dir}\033\\" 2>/dev/null
}
[ "$STY" ] && precmd_functions=($precmd_functions update_screen_title)

############################################################
##  windows で動いてる時は、job 一覧表示だけする
display_jobs(){ echo; jobs; }
[ "$OS" = "Windows_NT" ] && precmd_functions=(display_jobs)

############################################################
##  cdr の設定
autoload -Uz chpwd_recent_dirs cdr add-zsh-hook
add-zsh-hook chpwd chpwd_recent_dirs
zstyle ':chpwd:*' recent-dirs-max 1000
zstyle ':chpwd:*' recent-dirs-default yes
zstyle ':completion:*' recent-dirs-insert both

############################################################
##  zsh プロパティ

HISTFILE=$HOME/.zsh-history
HISTSIZE=100000
SAVEHIST=100000

## コアダンプサイズを制限
limit coredumpsize 102400

## 出力の文字列末尾に改行コードが無い場合でも表示
unsetopt promptcr

## 色を使う
setopt prompt_subst

## ビープを鳴らさない
setopt nobeep

## 内部コマンド jobs の出力をデフォルトで jobs -l にする
setopt long_list_jobs

## 補完候補一覧でファイルの種別をマーク表示
setopt list_types

## サスペンド中のプロセスと同じコマンド名を実行した場合はリジューム
setopt auto_resume

## 補完候補を一覧表示
setopt auto_list

## 直前と同じコマンドをヒストリに追加しない
setopt hist_ignore_dups

## cd 時に自動で push
setopt autopushd

## 同じディレクトリを pushd しない
setopt pushd_ignore_dups

## ファイル名で #, ~, ^ の 3 文字を正規表現として扱う
setopt extended_glob

## TAB で順に補完候補を切り替える
setopt auto_menu

## zsh の開始, 終了時刻をヒストリファイルに書き込む
setopt extended_history

## =command を command のパス名に展開する
setopt equals

## --prefix=/usr などの = 以降も補完
setopt magic_equal_subst

## ヒストリを呼び出してから実行する間に一旦編集
setopt hist_verify

# ファイル名の展開で辞書順ではなく数値的にソート
setopt numeric_glob_sort

## 出力時8ビットを通す
setopt print_eight_bit

## ヒストリを共有
setopt share_history

## 補完候補のカーソル選択を有効に
zstyle ':completion:*:default' menu select=1

## 補完候補の色づけ
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}

## ディレクトリ名だけで cd
setopt auto_cd

## カッコの対応などを自動的に補完
setopt auto_param_keys

## ディレクトリ名の補完で末尾の / を自動的に付加し、次の補完に備える
setopt auto_param_slash

## スペルチェック
#setopt correct

## sudo時にはsudo用のパスも使う。
zstyle ':completion:sudo:*' environ PATH="$SUDO_PATH:$PATH"

## 特定のコマンドの補完を無効化
# compdef -d java

# エンターキー入力時の挙動
do_enter() {
    if [[ -n "$BUFFER" ]]
    then
        zle accept-line
        return 0
    fi

    echo

    local threshold=20
    if [[ $(ls -A1 | wc -l) -lt $threshold ]]
    then ls -Ahl
    elif [[ $(ls -1 | wc -l) -lt $threshold ]]
    then ls -hl
    else ls
    fi

    if [[ -n "$VCS_NAME" ]]
    then
        echo
        echo -e "\e[0;33m### $VCS_NAME status #################\e[0m"
        case "$VCS_NAME" in
            git | svn ) which "$VCS_NAME" > /dev/null 2>&1 && "$VCS_NAME" status ;;
        esac
    fi

    if [[ $( jobs | wc -l ) -gt 0 ]]
    then
        echo
        echo -e "\e[0;33m### jobs #############################\e[0m"
        jobs
    fi

    echo -e "\n\n"
    zle reset-prompt
    return 0
}
zle -N do_enter
bindkey '^m' do_enter

#############################################################
# 時間のかかったコマンドは、通知システムに通知する
# 参考: http://qiita.com/hayamiz/items/d64730b61b7918fbb970

timetrack_threshold=10 # seconds

if which growlnotify >/dev/null 2>&1
then notify_method="growlnotify"
elif which notify-send >/dev/null 2>&1
then notify_method="notify-send"
fi

export timetrack_threshold
export timetrack_ignore_progs

unset timetrack_start
unset timetrack_command

function preexec_start_timetrack() {
    export timetrack_command="$1"
    export timetrack_start="`date +%s`"
}

function preexec_end_timetrack() {
    local command="$timetrack_command"
    local exec_time
    local message

    if [[ -z "$DISPLAY" || \
          -z "$notify-send" || \
          -z "$timetrack_start" || \
          -z "$timetrack_threshold" ]]
    then return
    fi

    if [[ -z "$command" ]]
    then command="<UNKNOWN>"
    fi

    export timetrack_end=`date +%s`

    exec_time="$(( timetrack_end - timetrack_start ))"

    if [[ "$exec_time" -ge "$timetrack_threshold" ]]
    then
        message="Time: $exec_time seconds\nCOMMAND: $command"
        case "$notify_method" in
            "growlnotify" )
                echo "$message" | growlnotify -n "ZSH timetracker" --appIcon Terminal
                ;;
            "notify-send" )
                notify-send "Command finished" "$message"
                ;;
        esac
    fi

    unset timetrack_start
    unset timetrack_command
}

if ( which growlnotify >/dev/null 2>&1 || which notify-send >/dev/null 2>&1 ) &&
    autoload -U add-zsh-hook 2>/dev/null
then
        add-zsh-hook preexec preexec_start_timetrack
        add-zsh-hook precmd preexec_end_timetrack
fi

## マシンごとの設定
! [[ -f ~/.zshrc.local ]] && touch ~/.zshrc.local
source ~/.zshrc.local

## rbenv
if which rbenv > /dev/null 2>&1 &&
    ! which rvm > /dev/null 2>&1
then
    echo load rbenv
    eval "$(rbenv init - zsh)"
fi

# zaw
if source_if_exist "$HOME/.zshrc.d/zaw/zaw.zsh"
then
    bindkey "^o"   zaw-cdr
    bindkey "^x^f" zaw-open-file
    bindkey "^r"   zaw-history
    bindkey "^xp"  zaw-process
    bindkey "^xb"  zaw-git-branches

    zstyle ':filter-select' case-insensitive yes
fi

# syntax-highligting
source_if_exist "$HOME/.zshrc.d/syntax-highlighting/zsh-syntax-highlighting.zsh"

# golang utillityes which be installed by dpkg (apt)
source_if_exist "/usr/lib/go/misc/zsh/go"

# npm
which npm > /dev/null 2>&1 && . <(npm completion)
